<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Devanagari Pronunciation Tool — QA</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#ffffff;
      --text:#111;
      --muted:#666;
      --border:#e6e6e6;
      --shadow:0 1px 2px rgba(0,0,0,.06);
      --accentBg:#f5f7ff;       /* subtle blue */
      --accentBorder:#cbd5ff;
      --okBg:#d4f8d4; --okBd:#2f9e44;
      --badBg:#ffd6d6; --badBd:#c92a2a;
      --warnBg:#fff3bf; --warnBd:#f08c00;
    }

    body{
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 16px;
      max-width: 980px;
      margin: 0 auto;
    }
    h1{ font-size: 20px; margin: 0 0 10px; }
    h2{ font-size: 16px; margin: 0 0 10px; }

    .small{ font-size: 13px; color: var(--muted); }
    .pill{
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background:#fafafa;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .okPill { background: var(--okBg); border-color: var(--okBd); }
    .badPill{ background: var(--badBg); border-color: var(--badBd); }
    .warnPill{ background: var(--warnBg); border-color: var(--warnBd); }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin: 10px 0 12px;
    }

    .card{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      background:#fff;
      box-sizing: border-box;
    }
    .cardAccent{
      background: var(--accentBg);
      border-color: var(--accentBorder);
    }

    label{ font-size: 14px; color:#333; }
    select, input[type="text"], textarea{
      font-size: 14px;
      padding: 8px 10px;
      border-radius: 10px;
      border:1px solid var(--border);
      background:#fff;
      outline:none;
    }
    select:focus, input[type="text"]:focus, textarea:focus{
      border-color:#b9c2ff;
      box-shadow: 0 0 0 3px rgba(185,194,255,.35);
    }

    button{
      font-size: 15px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: white;
      cursor: pointer;
      box-shadow: var(--shadow);
      user-select:none;
    }
    button:active{ transform: scale(0.98); }
    button.primary{
      border-color:#b9c2ff;
      background:#f6f7ff;
    }
    button.good{
      border-color: var(--okBd);
      background: var(--okBg);
    }
    button.bad{
      border-color: var(--badBd);
      background: var(--badBg);
    }
    button.ghost{
      background: transparent;
      box-shadow:none;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 720px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .bigGlyph{
      font-family: "Noto Sans Devanagari", system-ui, Arial, sans-serif;
      font-size: 54px;
      line-height: 1.1;
      margin: 0;
    }
    .metaLine{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 6px;
    }
    code.kv{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fbfbfb;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border:1px solid var(--border);
      background:#fff;
      border-bottom-width:2px;
      border-radius: 6px;
    }

    textarea{ width: 100%; min-height: 70px; resize: vertical; }

    .mutedBox{
      border:1px dashed var(--border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(255,255,255,.6);
    }

    .dangerNote{
      margin-top: 8px;
      font-size: 13px;
      color: #7a2e2e;
    }

    .linkLike{
      color:#364fc7;
      text-decoration: underline;
      cursor:pointer;
    }
  </style>
</head>

<body>
  <h1>QA — Recording Review</h1>

  <div class="card cardAccent">
    <div class="row" style="margin-top:0;">
      <span class="pill" id="qaStatus">Ready</span>
      <span class="pill" id="qaCounts">—</span>
      <span class="pill" id="qaProgress">—</span>
    </div>

    <p class="small" style="margin:0 0 10px;">
      <b>How to use:</b> Choose a dataset, then press <b>Next (Play)</b> to advance and hear the current item.
      Approve or Reject, add a note if needed, and keep going.
      <span class="small">(Shortcuts: <span class="kbd">N</span> next, <span class="kbd">P</span> play, <span class="kbd">A</span> approve, <span class="kbd">R</span> reject)</span>
    </p>

    <div class="row">
      <label>
        Dataset:
        <select id="qaDataset">
          <option value="gunita_words" selected>Gunita words (words.json)</option>
          <option value="conj_words">Conjunct words (conj/conjunct_words.json)</option>
          <option value="conj_items">Conjunct audios (conj/conjuncts.json)</option>
          <!-- OPTIONAL: add your own lists here if you want -->
          <option value="custom_inline">Custom inline list (edit in qa.html)</option>
        </select>
      </label>

      <label>
        Filter:
        <select id="qaFilter">
          <option value="all" selected>All</option>
          <option value="unreviewed">Unreviewed</option>
          <option value="approved">Approved</option>
          <option value="rejected">Rejected</option>
        </select>
      </label>

      <label>
        Level:
        <select id="qaLevel">
          <option value="all" selected>All</option>
          <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>
        </select>
      </label>

      <label id="qaModuleWrap" style="display:none;">
        Module:
        <select id="qaModule">
          <option value="ALL" selected>All</option>
          <option value="A">A</option><option value="B">B</option><option value="C">C</option>
          <option value="D">D</option><option value="E">E</option><option value="F">F</option><option value="G">G</option>
        </select>
      </label>
    </div>

    <div class="row">
      <button id="qaPrev" class="ghost">Prev</button>
      <button id="qaNext" class="primary">Next (Play)</button>
      <button id="qaPlay">Play</button>
      <button id="qaApprove" class="good">Approve</button>
      <button id="qaReject" class="bad">Reject</button>
      <button id="qaClearDecision">Clear decision</button>
      <button id="qaResetAll" class="ghost" title="Clears ALL saved QA decisions for this tool">Reset QA data</button>
    </div>
  </div>

  <div class="grid2" style="margin-top:14px;">
    <div class="card">
      <h2 style="margin-top:0;">Current item</h2>
      <p class="bigGlyph" id="qaGlyph">—</p>

      <div class="metaLine">
        <code class="kv" id="qaHint">hint: —</code>
        <code class="kv" id="qaId">id: —</code>
        <code class="kv" id="qaModuleTag" style="display:none;">module: —</code>
        <code class="kv" id="qaLevelTag">level: —</code>
      </div>

      <div class="metaLine" style="margin-top:10px;">
        <span class="pill" id="qaDecision">Decision: —</span>
        <span class="pill" id="qaAudioFile">Audio: —</span>
      </div>

      <div class="dangerNote" id="qaMissingNote" style="display:none;">
        This audio file looks missing or blank. Use Reject (or Clear decision) and fix later.
      </div>

      <div style="margin-top:12px;">
        <div class="small" style="margin-bottom:6px;"><b>Reviewer note</b> (optional)</div>
        <textarea id="qaNote" placeholder="e.g., vowel length off, aspiration weak, background noise, clipped…"></textarea>
        <div class="row" style="margin:10px 0 0;">
          <button id="qaSaveNote">Save note</button>
          <button id="qaExport" class="primary">Export TSV</button>
        </div>
        <div class="small mutedBox" style="margin-top:10px;">
          Saved locally in your browser (localStorage). Export TSV to share with others.
        </div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin-top:0;">Guidance (quick rubric)</h2>
      <ul class="small" style="margin-top:0; padding-left:18px;">
        <li><b>Correct phoneme:</b> retroflex vs dental, ś/ṣ/s, aspiration, anusvāra/visarga.</li>
        <li><b>Vowel length:</b> a/ā, i/ī, u/ū, ṛ/ṝ.</li>
        <li><b>Clarity:</b> no clipping, consistent loudness, low noise.</li>
        <li><b>Timing:</b> not cut off at start/end.</li>
      </ul>

      <h2>Data sources used</h2>
      <div class="small mutedBox">
        <div><b>Gunita words:</b> <code>words.json</code></div>
        <div><b>Conjunct words:</b> <code>conj/conjunct_words.json</code></div>
        <div><b>Conjunct audios:</b> <code>conj/conjuncts.json</code></div>
      </div>

      <p class="small" style="margin-top:10px;">
        If you see “Could not play …”, it usually means the file path in JSON is wrong or the mp3 isn’t uploaded.
      </p>

      <p class="small">
        Tip: If you want <b>QA for vowels/consonants/gunita letters</b> too, add them into the
        <span class="linkLike" id="jumpInline">Custom inline list</span> section inside this file.
      </p>
    </div>
  </div>

  <script>
    // -----------------------------
    // CONFIG
    // -----------------------------
    const AUDIO_BASE_URL = "https://laksiyer.github.io/ucchAraNam/audio/"; // must end with /

    // OPTIONAL: You can add a small inline list here and pick Dataset = "Custom inline list"
    // Format: { id, glyph, hint, level, file, module }
    const QA_INLINE = [
      // { id:"x001", glyph:"अ", hint:"a", level:1, file:"a.mp3", module:"" },
    ];

    // -----------------------------
    // UI refs
    // -----------------------------
    const qaStatus = document.getElementById("qaStatus");
    const qaCounts = document.getElementById("qaCounts");
    const qaProgress = document.getElementById("qaProgress");

    const qaDataset = document.getElementById("qaDataset");
    const qaFilter = document.getElementById("qaFilter");
    const qaLevel = document.getElementById("qaLevel");
    const qaModuleWrap = document.getElementById("qaModuleWrap");
    const qaModule = document.getElementById("qaModule");

    const qaPrev = document.getElementById("qaPrev");
    const qaNext = document.getElementById("qaNext");
    const qaPlay = document.getElementById("qaPlay");
    const qaApprove = document.getElementById("qaApprove");
    const qaReject = document.getElementById("qaReject");
    const qaClearDecision = document.getElementById("qaClearDecision");
    const qaResetAll = document.getElementById("qaResetAll");

    const qaGlyph = document.getElementById("qaGlyph");
    const qaHint = document.getElementById("qaHint");
    const qaId = document.getElementById("qaId");
    const qaModuleTag = document.getElementById("qaModuleTag");
    const qaLevelTag = document.getElementById("qaLevelTag");
    const qaDecision = document.getElementById("qaDecision");
    const qaAudioFile = document.getElementById("qaAudioFile");
    const qaMissingNote = document.getElementById("qaMissingNote");

    const qaNote = document.getElementById("qaNote");
    const qaSaveNote = document.getElementById("qaSaveNote");
    const qaExport = document.getElementById("qaExport");
    const jumpInline = document.getElementById("jumpInline");

    // -----------------------------
    // Audio player
    // -----------------------------
    const player = new Audio();
    player.preload = "auto";

    function setStatus(msg, kind="neutral"){
      qaStatus.textContent = msg;
      qaStatus.classList.remove("okPill","badPill","warnPill");
      if (kind==="ok") qaStatus.classList.add("okPill");
      if (kind==="bad") qaStatus.classList.add("badPill");
      if (kind==="warn") qaStatus.classList.add("warnPill");
    }

    function playFile(file, label="audio"){
      if (!file) { setStatus("No audio for this item", "warn"); return; }
      try { player.pause(); player.currentTime = 0; } catch(e){}
      const url = AUDIO_BASE_URL + file.replace(/^\/+/,"");
      player.src = url;
      setStatus("Loading…", "neutral");
      player.play()
        .then(()=> setStatus("Playing", "ok"))
        .catch(()=> setStatus("Could not play: " + url, "bad"));
    }

    // -----------------------------
    // Load datasets
    // -----------------------------
    let WORDS = [], WORDS_READY = false;
    let CONJ_WORDS = [], CONJ_WORDS_READY = false;
    let CONJ = [], CONJ_READY = false;

    async function fetchJson(path){
      const res = await fetch(path + "?v=" + Date.now());
      if (!res.ok) throw new Error("HTTP " + res.status + " for " + path);
      return await res.json();
    }

    async function loadAll(){
      // We load all 3 so switching datasets is instant
      try{
        WORDS = await fetchJson("words.json");
        WORDS_READY = Array.isArray(WORDS);
      }catch(e){ console.error(e); WORDS=[]; WORDS_READY=false; }

      try{
        CONJ_WORDS = await fetchJson("conj/conjunct_words.json");
        CONJ_WORDS_READY = Array.isArray(CONJ_WORDS);
      }catch(e){ console.error(e); CONJ_WORDS=[]; CONJ_WORDS_READY=false; }

      try{
        CONJ = await fetchJson("conj/conjuncts.json");
        CONJ_READY = Array.isArray(CONJ);
      }catch(e){ console.error(e); CONJ=[]; CONJ_READY=false; }

      setStatus("Loaded datasets", "ok");
      qaRebuildList(true);
    }

    // -----------------------------
    // QA model
    // Item model: { key, id, glyph, hint, level, file, module, source }
    // -----------------------------
    let qaAll = [];
    let qaList = [];
    let qaIdx = -1;

    // Decisions stored in localStorage:
    // key -> { decision: "approved"/"rejected"/"", note:"", t: timestamp }
    const LS_KEY = "uccharanam_qa_v1";

    function loadStore(){
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
      catch(e){ return {}; }
    }
    function saveStore(obj){
      localStorage.setItem(LS_KEY, JSON.stringify(obj));
    }
    function getEntry(key){
      const st = loadStore();
      return st[key] || null;
    }
    function setEntry(key, patch){
      const st = loadStore();
      st[key] = { ...(st[key]||{}), ...patch, t: Date.now() };
      saveStore(st);
    }
    function clearEntry(key){
      const st = loadStore();
      delete st[key];
      saveStore(st);
    }
    function resetStore(){
      localStorage.removeItem(LS_KEY);
    }

    function conjIdToModuleMap(){
      const m = new Map();
      if (Array.isArray(CONJ)) CONJ.forEach(x => { if (x && x.id) m.set(x.id, x.module || ""); });
      return m;
    }

    function buildDatasetItems(){
      const ds = qaDataset.value;
      const items = [];

      if (ds === "gunita_words") {
        if (WORDS_READY) {
          WORDS.forEach(w=>{
            const id = w.id || "";
            const glyph = w.word || "";
            const hint = w.hint || "";
            const level = w.level ?? "";
            const file = w.file || "";
            const key = `words:${id}:${file}`;
            items.push({ key, id, glyph, hint, level, file, module:"", source:"words.json" });
          });
        }
      }

      if (ds === "conj_words") {
        if (CONJ_WORDS_READY) {
          const idToMod = conjIdToModuleMap();
          CONJ_WORDS.forEach(w=>{
            const cid = w.conj_id || "";
            const glyph = w.word || "";
            const hint = w.hint || "";
            const level = w.level ?? "";
            const file = w.file || "";
            const mod = idToMod.get(cid) || "";
            const idx = w.idx ?? "";
            const key = `conj_words:${cid}:${idx}:${file}`;
            items.push({ key, id: cid, glyph, hint, level, file, module: mod, source:"conj/conjunct_words.json" });
          });
        }
      }

      if (ds === "conj_items") {
        if (CONJ_READY) {
          CONJ.forEach(x=>{
            const id = x.id || "";
            const glyph = x.form || "";
            const hint = x.hint || "";
            const mod = x.module || "";
            const file = x.audio || ""; // may be blank
            const level = "";           // conjunct list has no level
            const key = `conj_items:${id}:${file}`;
            items.push({ key, id, glyph, hint, level, file, module: mod, source:"conj/conjuncts.json" });
          });
        }
      }

      if (ds === "custom_inline") {
        QA_INLINE.forEach(x=>{
          const id = x.id || "";
          const glyph = x.glyph || "";
          const hint = x.hint || "";
          const level = x.level ?? "";
          const file = x.file || "";
          const mod = x.module || "";
          const key = `inline:${id}:${file}`;
          items.push({ key, id, glyph, hint, level, file, module: mod, source:"qa_inline" });
        });
      }

      return items.filter(x => x && x.glyph);
    }

    function applyFilters(items){
      const f = qaFilter.value;
      const lvl = qaLevel.value;
      const mod = qaModule.value;

      return items.filter(it=>{
        const entry = getEntry(it.key);
        const decision = entry?.decision || "";

        // Decision filter
        if (f === "unreviewed" && decision) return false;
        if (f === "approved" && decision !== "approved") return false;
        if (f === "rejected" && decision !== "rejected") return false;

        // Level filter (only if item has level)
        if (lvl !== "all" && String(it.level ?? "") !== String(lvl)) return false;

        // Module filter (only for conjunct datasets)
        if (qaModuleWrap.style.display !== "none") {
          if (mod !== "ALL" && String(it.module || "") !== String(mod)) return false;
        }

        return true;
      });
    }

    function updateCounts(){
      const all = qaAll.length;
      let approved=0, rejected=0, unreviewed=0;
      qaAll.forEach(it=>{
        const d = (getEntry(it.key)?.decision || "");
        if (d==="approved") approved++;
        else if (d==="rejected") rejected++;
        else unreviewed++;
      });
      qaCounts.textContent = `All: ${all} · ✅ ${approved} · ❌ ${rejected} · ⏳ ${unreviewed}`;

      if (!qaList.length) qaProgress.textContent = "0 / 0";
      else qaProgress.textContent = `${qaIdx+1} / ${qaList.length}`;
    }

    function currentItem(){ return (qaIdx>=0 && qaIdx<qaList.length) ? qaList[qaIdx] : null; }

    function renderCurrent(){
      const it = currentItem();
      updateCounts();

      if (!it){
        qaGlyph.textContent = "—";
        qaHint.textContent = "hint: —";
        qaId.textContent = "id: —";
        qaModuleTag.style.display = "none";
        qaLevelTag.textContent = "level: —";
        qaDecision.textContent = "Decision: —";
        qaAudioFile.textContent = "Audio: —";
        qaMissingNote.style.display = "none";
        qaNote.value = "";
        setStatus("No items for this filter", "warn");
        return;
      }

      qaGlyph.textContent = it.glyph;
      qaHint.textContent = "hint: " + (it.hint || "—");
      qaId.textContent = "id: " + (it.id || "—");
      qaLevelTag.textContent = "level: " + (it.level === "" ? "—" : it.level);

      if (it.module) {
        qaModuleTag.style.display = "inline-block";
        qaModuleTag.textContent = "module: " + it.module;
      } else {
        qaModuleTag.style.display = "none";
      }

      qaAudioFile.textContent = "Audio: " + (it.file || "(blank)");
      qaMissingNote.style.display = (!it.file) ? "block" : "none";

      const entry = getEntry(it.key);
      const decision = entry?.decision || "";
      const note = entry?.note || "";
      qaNote.value = note;

      if (!decision) qaDecision.textContent = "Decision: —";
      if (decision==="approved") qaDecision.textContent = "Decision: ✅ Approved";
      if (decision==="rejected") qaDecision.textContent = "Decision: ❌ Rejected";
    }

    function qaRebuildList(resetIndex=false){
      // Toggle Module selector only for conjunct datasets
      const ds = qaDataset.value;
      const needsModule = (ds === "conj_words" || ds === "conj_items");
      qaModuleWrap.style.display = needsModule ? "inline-flex" : "none";

      qaAll = buildDatasetItems();
      qaList = applyFilters(qaAll);

      if (resetIndex) qaIdx = -1;
      if (qaIdx >= qaList.length) qaIdx = qaList.length - 1;
      renderCurrent();
    }

    // -----------------------------
    // Navigation + actions
    // -----------------------------
    function qaNextAndPlay(){
      if (!qaList.length) { renderCurrent(); return; }
      qaIdx++;
      if (qaIdx >= qaList.length) qaIdx = 0;
      renderCurrent();
      qaPlayNow();
    }

    function qaPrevOnly(){
      if (!qaList.length) { renderCurrent(); return; }
      qaIdx--;
      if (qaIdx < 0) qaIdx = qaList.length - 1;
      renderCurrent();
    }

    function qaPlayNow(){
      const it = currentItem();
      if (!it) return;
      playFile(it.file, it.glyph);
    }

    function qaApproveNow(){
      const it = currentItem();
      if (!it) return;
      setEntry(it.key, { decision: "approved" });
      setStatus("Approved", "ok");
      renderCurrent();
    }

    function qaRejectNow(){
      const it = currentItem();
      if (!it) return;
      setEntry(it.key, { decision: "rejected" });
      setStatus("Rejected", "bad");
      renderCurrent();
    }

    function qaClearDecisionNow(){
      const it = currentItem();
      if (!it) return;
      const entry = getEntry(it.key);
      if (entry?.note) {
        // keep note but clear decision
        setEntry(it.key, { decision: "" });
      } else {
        clearEntry(it.key);
      }
      setStatus("Cleared decision", "neutral");
      renderCurrent();
    }

    function qaSaveNoteNow(){
      const it = currentItem();
      if (!it) return;
      const note = (qaNote.value || "").trim();
      setEntry(it.key, { note });
      setStatus(note ? "Note saved" : "Note cleared", "ok");
      renderCurrent();
    }

    function qaResetEverything(){
      if (!confirm("This will delete ALL QA decisions/notes saved in this browser for this tool. Continue?")) return;
      resetStore();
      setStatus("QA data reset", "warn");
      qaRebuildList(false);
    }

    function tsvEscape(s){
      s = (s ?? "").toString();
      // TSV-safe: replace newlines and tabs
      return s.replace(/\t/g," ").replace(/\r?\n/g,"  ");
    }

    function qaExportTSV(){
      const st = loadStore();
      const rows = [];
      rows.push(["key","dataset","id","glyph","hint","level","module","file","decision","note","timestamp"].join("\t"));

      qaAll.forEach(it=>{
        const entry = st[it.key] || {};
        const decision = entry.decision || "";
        const note = entry.note || "";
        const ts = entry.t ? new Date(entry.t).toISOString() : "";
        rows.push([
          tsvEscape(it.key),
          tsvEscape(it.source),
          tsvEscape(it.id),
          tsvEscape(it.glyph),
          tsvEscape(it.hint),
          tsvEscape(it.level),
          tsvEscape(it.module),
          tsvEscape(it.file),
          tsvEscape(decision),
          tsvEscape(note),
          tsvEscape(ts),
        ].join("\t"));
      });

      const blob = new Blob([rows.join("\n")], { type: "text/tab-separated-values;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "qa_export.tsv";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus("Exported qa_export.tsv", "ok");
    }

    // -----------------------------
    // Wiring
    // -----------------------------
    qaDataset.addEventListener("change", ()=> qaRebuildList(true));
    qaFilter.addEventListener("change", ()=> qaRebuildList(true));
    qaLevel.addEventListener("change", ()=> qaRebuildList(true));
    qaModule.addEventListener("change", ()=> qaRebuildList(true));

    qaPrev.addEventListener("click", qaPrevOnly);
    qaNext.addEventListener("click", qaNextAndPlay);
    qaPlay.addEventListener("click", qaPlayNow);
    qaApprove.addEventListener("click", qaApproveNow);
    qaReject.addEventListener("click", qaRejectNow);
    qaClearDecision.addEventListener("click", qaClearDecisionNow);
    qaSaveNote.addEventListener("click", qaSaveNoteNow);
    qaExport.addEventListener("click", qaExportTSV);
    qaResetAll.addEventListener("click", qaResetEverything);

    jumpInline.addEventListener("click", ()=>{
      qaDataset.value = "custom_inline";
      qaRebuildList(true);
      setStatus("Now using Custom inline list (edit QA_INLINE in qa.html)", "warn");
    });

    // Keyboard shortcuts (ignore when typing in textarea)
    document.addEventListener("keydown", (e)=>{
      const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
      if (tag === "textarea" || tag === "input" || tag === "select") return;

      const k = e.key.toLowerCase();
      if (k === "n") { e.preventDefault(); qaNextAndPlay(); }
      if (k === "p" || k === " ") { e.preventDefault(); qaPlayNow(); }
      if (k === "a") { e.preventDefault(); qaApproveNow(); }
      if (k === "r") { e.preventDefault(); qaRejectNow(); }
    });

    // -----------------------------
    // Boot
    // -----------------------------
    loadAll().then(()=>{
      // Start with first item ready; user presses Next(Play) or you can auto-start:
      // qaNextAndPlay();
      setStatus("Ready — press Next (Play)", "ok");
    });
  </script>
</body>
</html>
