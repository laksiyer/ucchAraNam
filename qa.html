<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Devanagari Pronunciation Tool — QA</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Devanagari:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#ffffff;
      --text:#111;
      --muted:#666;
      --border:#e6e6e6;
      --shadow:0 1px 2px rgba(0,0,0,.06);
      --accentBg:#f5f7ff;
      --accentBorder:#cbd5ff;
      --okBg:#d4f8d4; --okBd:#2f9e44;
      --badBg:#ffd6d6; --badBd:#c92a2a;
      --warnBg:#fff3bf; --warnBd:#f08c00;
    }

    body{
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 16px;
      max-width: 980px;
      margin: 0 auto;
    }
    h1{ font-size: 20px; margin: 0 0 10px; }
    h2{ font-size: 16px; margin: 0 0 10px; }

    .small{ font-size: 13px; color: var(--muted); }
    .pill{
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background:#fafafa;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .okPill { background: var(--okBg); border-color: var(--okBd); }
    .badPill{ background: var(--badBg); border-color: var(--badBd); }
    .warnPill{ background: var(--warnBg); border-color: var(--warnBd); }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin: 10px 0 12px;
    }

    .card{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: var(--shadow);
      background:#fff;
      box-sizing: border-box;
    }
    .cardAccent{
      background: var(--accentBg);
      border-color: var(--accentBorder);
    }

    label{ font-size: 14px; color:#333; }
    select, textarea{
      font-size: 14px;
      padding: 8px 10px;
      border-radius: 10px;
      border:1px solid var(--border);
      background:#fff;
      outline:none;
    }
    select:focus, textarea:focus{
      border-color:#b9c2ff;
      box-shadow: 0 0 0 3px rgba(185,194,255,.35);
    }

    button{
      font-size: 15px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: white;
      cursor: pointer;
      box-shadow: var(--shadow);
      user-select:none;
    }
    button:active{ transform: scale(0.98); }
    button.primary{
      border-color:#b9c2ff;
      background:#f6f7ff;
    }
    button.good{
      border-color: var(--okBd);
      background: var(--okBg);
    }
    button.bad{
      border-color: var(--badBd);
      background: var(--badBg);
    }
    button.ghost{
      background: transparent;
      box-shadow:none;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 720px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .bigGlyph{
      font-family: "Noto Sans Devanagari", system-ui, Arial, sans-serif;
      font-size: 54px;
      line-height: 1.1;
      margin: 0;
    }
    .metaLine{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 6px;
    }
    code.kv{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fbfbfb;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border:1px solid var(--border);
      background:#fff;
      border-bottom-width:2px;
      border-radius: 6px;
    }

    textarea{ width: 100%; min-height: 70px; resize: vertical; }

    .mutedBox{
      border:1px dashed var(--border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(255,255,255,.6);
    }

    .dangerNote{
      margin-top: 8px;
      font-size: 13px;
      color: #7a2e2e;
    }

    .linkLike{
      color:#364fc7;
      text-decoration: underline;
      cursor:pointer;
    }
  </style>
</head>

<body>
  <h1>QA — Recording Review</h1>

  <div class="card cardAccent">
    <div class="row" style="margin-top:0;">
      <span class="pill" id="qaStatus">Ready</span>
      <span class="pill" id="qaCounts">—</span>
      <span class="pill" id="qaProgress">—</span>
    </div>

    <p class="small" style="margin:0 0 10px;">
      <b>How to use:</b> Choose a dataset, then press <b>Next (Play)</b> to advance and hear the current item.
      Approve or Reject, add a note if needed, and keep going.
      <span class="small">(Shortcuts: <span class="kbd">N</span> next, <span class="kbd">P</span> play, <span class="kbd">A</span> approve, <span class="kbd">R</span> reject)</span>
    </p>

    <div class="row">
      <label>
        Dataset:
        <select id="qaDataset">
          <option value="vowels" selected>Vowels (स्वराः)</option>
          <option value="vargiya">Vargīya consonants (वर्गीय)</option>
          <option value="avargiya">Avargīya consonants (अवर्गीय)</option>
          <option value="gunita">Guṇitākṣarāṇi (गुणिताक्षराणि)</option>

          <option value="gunita_words">Gunita words (words.json)</option>
          <option value="conj_words">Conjunct words (conj/conjunct_words.json)</option>
          <option value="conj_items">Conjunct audios (conj/conjuncts.json)</option>

          <option value="custom_inline">Custom inline list (edit in qa.html)</option>
        </select>
      </label>

      <label>
        Filter:
        <select id="qaFilter">
          <option value="all" selected>All</option>
          <option value="unreviewed">Unreviewed</option>
          <option value="approved">Approved</option>
          <option value="rejected">Rejected</option>
        </select>
      </label>

      <label>
        Level:
        <select id="qaLevel">
          <option value="all" selected>All</option>
          <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>
        </select>
      </label>

      <label id="qaModuleWrap" style="display:none;">
        Module:
        <select id="qaModule">
          <option value="ALL" selected>All</option>
          <option value="A">A</option><option value="B">B</option><option value="C">C</option>
          <option value="D">D</option><option value="E">E</option><option value="F">F</option><option value="G">G</option>
        </select>
      </label>
    </div>

    <div class="row">
      <button id="qaPrev" class="ghost">Prev</button>
      <button id="qaNext" class="primary">Next (Play)</button>
      <button id="qaPlay">Play</button>
      <button id="qaApprove" class="good">Approve</button>
      <button id="qaReject" class="bad">Reject</button>
      <button id="qaClearDecision">Clear decision</button>
      <button id="qaResetAll" class="ghost" title="Clears ALL saved QA decisions for this tool">Reset QA data</button>
    </div>

    <div class="small mutedBox" id="dsHelp" style="margin-top:10px;">
      <b>Note:</b> For <b>Guṇitākṣarāṇi</b>, this page generates file names like
      <code>ka_a.mp3</code>, <code>ka_aa.mp3</code>, … based on the stems below. If a stem/file doesn’t match your actual naming, edit the stems list.
    </div>
  </div>

  <div class="grid2" style="margin-top:14px;">
    <div class="card">
      <h2 style="margin-top:0;">Current item</h2>
      <p class="bigGlyph" id="qaGlyph">—</p>

      <div class="metaLine">
        <code class="kv" id="qaHint">hint: —</code>
        <code class="kv" id="qaId">id: —</code>
        <code class="kv" id="qaModuleTag" style="display:none;">module: —</code>
        <code class="kv" id="qaLevelTag">level: —</code>
      </div>

      <div class="metaLine" style="margin-top:10px;">
        <span class="pill" id="qaDecision">Decision: —</span>
        <span class="pill" id="qaAudioFile">Audio: —</span>
      </div>

      <div class="dangerNote" id="qaMissingNote" style="display:none;">
        This item has a blank audio path (or a mismatch). Fix the filename or upload later.
      </div>

      <div style="margin-top:12px;">
        <div class="small" style="margin-bottom:6px;"><b>Reviewer note</b> (optional)</div>
        <textarea id="qaNote" placeholder="e.g., vowel length off, aspiration weak, background noise, clipped…"></textarea>
        <div class="row" style="margin:10px 0 0;">
          <button id="qaSaveNote">Save note</button>
          <button id="qaExport" class="primary">Export TSV</button>
        </div>
        <div class="small mutedBox" style="margin-top:10px;">
          Saved locally in your browser (localStorage). Export TSV to share with others.
        </div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin-top:0;">Guidance (quick rubric)</h2>
      <ul class="small" style="margin-top:0; padding-left:18px;">
        <li><b>Correct phoneme:</b> retroflex vs dental, ś/ṣ/s, aspiration, anusvāra/visarga.</li>
        <li><b>Vowel length:</b> a/ā, i/ī, u/ū, ṛ/ṝ.</li>
        <li><b>Clarity:</b> no clipping, consistent loudness, low noise.</li>
        <li><b>Timing:</b> not cut off at start/end.</li>
      </ul>

      <h2>Data sources used</h2>
      <div class="small mutedBox">
        <div><b>Built-in:</b> vowels / consonants / gunita</div>
        <div><b>Gunita words:</b> <code>words.json</code></div>
        <div><b>Conjunct words:</b> <code>conj/conjunct_words.json</code></div>
        <div><b>Conjunct audios:</b> <code>conj/conjuncts.json</code></div>
      </div>

      <p class="small" style="margin-top:10px;">
        If you see “Could not play …”, it usually means the file path is wrong or the mp3 isn’t uploaded.
      </p>

      <p class="small">
        Tip: Want QA for anything else? Add to
        <span class="linkLike" id="jumpInline">Custom inline list</span> inside this file.
      </p>
    </div>
  </div>

  <script>
    // -----------------------------
    // CONFIG
    // -----------------------------
    const AUDIO_BASE_URL = "https://laksiyer.github.io/ucchAraNam/audio/"; // must end with /

    // --- BUILT-IN DATASETS (edit filenames here if yours differ) ---

    const QA_VOWELS = [
      { id:"v_a",  glyph:"अ",  hint:"a",   level:1, file:"a.mp3" },
      { id:"v_aa", glyph:"आ",  hint:"ā",   level:1, file:"aa.mp3" },
      { id:"v_i",  glyph:"इ",  hint:"i",   level:1, file:"i.mp3" },
      { id:"v_ii", glyph:"ई",  hint:"ī",   level:1, file:"ii.mp3" },
      { id:"v_u",  glyph:"उ",  hint:"u",   level:1, file:"u.mp3" },
      { id:"v_uu", glyph:"ऊ",  hint:"ū",   level:1, file:"uu.mp3" },
      { id:"v_ri", glyph:"ऋ",  hint:"ṛ",   level:2, file:"ri.mp3" },
      { id:"v_rri",glyph:"ॠ",  hint:"ṝ",   level:3, file:"rri.mp3" },
      { id:"v_e",  glyph:"ए",  hint:"e",   level:1, file:"e.mp3" },
      { id:"v_ai", glyph:"ऐ",  hint:"ai",  level:2, file:"ai.mp3" },
      { id:"v_o",  glyph:"ओ",  hint:"o",   level:1, file:"o.mp3" },
      { id:"v_au", glyph:"औ",  hint:"au",  level:2, file:"au.mp3" },
      { id:"v_am", glyph:"अं", hint:"aṃ",  level:2, file:"am.mp3" },
      { id:"v_ah", glyph:"अः", hint:"aḥ",  level:2, file:"ah.mp3" }
    ];

    // Base consonant lists (use YOUR actual filenames)
    const QA_VARGIYA = [
      { id:"c_ka", glyph:"क", hint:"ka", level:1, file:"ka.mp3" },
      { id:"c_kha",glyph:"ख", hint:"kha",level:1, file:"kha.mp3" },
      { id:"c_ga", glyph:"ग", hint:"ga", level:1, file:"ga.mp3" },
      { id:"c_gha",glyph:"घ", hint:"gha",level:2, file:"gha.mp3" },
      { id:"c_nga",glyph:"ङ", hint:"ṅa", level:2, file:"nga.mp3" },

      { id:"c_ca", glyph:"च", hint:"ca", level:1, file:"ca.mp3" },
      { id:"c_cha",glyph:"छ", hint:"cha",level:1, file:"cha.mp3" },
      { id:"c_ja", glyph:"ज", hint:"ja", level:1, file:"ja.mp3" },
      { id:"c_jha",glyph:"झ", hint:"jha",level:2, file:"jha.mp3" },
      { id:"c_nya",glyph:"ञ", hint:"ña", level:2, file:"nya.mp3" },

      // Your earlier naming for retroflex base files:
      { id:"c_tta", glyph:"ट", hint:"ṭa",  level:2, file:"ta_retro.mp3" },
      { id:"c_ttha",glyph:"ठ", hint:"ṭha", level:2, file:"tha_retro.mp3" },
      { id:"c_dda", glyph:"ड", hint:"ḍa",  level:2, file:"da_retro.mp3" },
      { id:"c_ddha",glyph:"ढ", hint:"ḍha", level:3, file:"dha_retro.mp3" },
      { id:"c_nna", glyph:"ण", hint:"ṇa",  level:2, file:"na_retro.mp3" },

      { id:"c_ta",  glyph:"त", hint:"ta",  level:1, file:"ta.mp3" },
      { id:"c_tha", glyph:"थ", hint:"tha", level:1, file:"tha.mp3" },
      { id:"c_da",  glyph:"द", hint:"da",  level:1, file:"da.mp3" },
      { id:"c_dha", glyph:"ध", hint:"dha", level:2, file:"dha.mp3" },
      { id:"c_na",  glyph:"न", hint:"na",  level:1, file:"na.mp3" },

      { id:"c_pa",  glyph:"प", hint:"pa",  level:1, file:"pa.mp3" },
      { id:"c_pha", glyph:"फ", hint:"pha", level:2, file:"pha.mp3" },
      { id:"c_ba",  glyph:"ब", hint:"ba",  level:1, file:"ba.mp3" },
      { id:"c_bha", glyph:"भ", hint:"bha", level:2, file:"bha.mp3" },
      { id:"c_ma",  glyph:"म", hint:"ma",  level:1, file:"ma.mp3" }
    ];

    const QA_AVARGIYA = [
      { id:"a_ya", glyph:"य", hint:"ya", level:1, file:"ya.mp3" },
      { id:"a_ra", glyph:"र", hint:"ra", level:1, file:"ra.mp3" },
      { id:"a_la", glyph:"ल", hint:"la", level:1, file:"la.mp3" },
      { id:"a_va", glyph:"व", hint:"va", level:1, file:"va.mp3" },
      { id:"a_sha",glyph:"श", hint:"śa", level:2, file:"sha_palatal.mp3" },
      { id:"a_ssa",glyph:"ष", hint:"ṣa", level:2, file:"sha_retro.mp3" },
      { id:"a_sa", glyph:"स", hint:"sa", level:1, file:"sa.mp3" },
      { id:"a_ha", glyph:"ह", hint:"ha", level:1, file:"ha.mp3" }
    ];

    // ---- GUNITA GENERATOR ----
    // This must match YOUR file naming scheme:  stem + "_" + vowelKey + ".mp3"
    // Example: "ka_a.mp3", "ka_aa.mp3", ... "tta_aa.mp3", etc.
    const GUNITA_VOWELS = [
      { key:"a",  label:"अ",  hint:"a"  },
      { key:"aa", label:"आ",  hint:"ā"  },
      { key:"i",  label:"इ",  hint:"i"  },
      { key:"ii", label:"ई",  hint:"ī"  },
      { key:"u",  label:"उ",  hint:"u"  },
      { key:"uu", label:"ऊ",  hint:"ū"  },
      { key:"ri", label:"ऋ",  hint:"ṛ"  },
      { key:"rri",label:"ॠ",  hint:"ṝ"  },
      { key:"e",  label:"ए",  hint:"e"  },
      { key:"ai", label:"ऐ",  hint:"ai" },
      { key:"o",  label:"ओ",  hint:"o"  },
      { key:"au", label:"औ",  hint:"au" },
      { key:"am", label:"अं", hint:"aṃ" },
      { key:"ah", label:"अः", hint:"aḥ" }
    ];

    // IMPORTANT: Put YOUR guṇita stems here. This is where most “missing” issues come from.
    // Use exactly the base you used while naming: e.g. ka_a.mp3 -> stem "ka"
    // For your retroflex set you said: tta_aa.mp3, ttha_ii.mp3, dda_u.mp3 ...
    // so stems should be: "tta", "ttha", "dda", "ddha", "nna"
    const GUNITA_STEMS = [
      // gutturals
      { id:"g_ka",  glyph:"क", hint:"ka",  level:1, stem:"ka" },
      { id:"g_kha", glyph:"ख", hint:"kha", level:1, stem:"kha" },
      { id:"g_ga",  glyph:"ग", hint:"ga",  level:1, stem:"ga" },
      { id:"g_gha", glyph:"घ", hint:"gha", level:2, stem:"gha" },
      { id:"g_nga", glyph:"ङ", hint:"ṅa",  level:2, stem:"nga" },

      // palatals
      { id:"g_ca",  glyph:"च", hint:"ca",  level:1, stem:"ca" },
      { id:"g_cha", glyph:"छ", hint:"cha", level:1, stem:"cha" },
      { id:"g_ja",  glyph:"ज", hint:"ja",  level:1, stem:"ja" },
      { id:"g_jha", glyph:"झ", hint:"jha", level:2, stem:"jha" },
      { id:"g_nya", glyph:"ञ", hint:"ña",  level:2, stem:"nya" },

      // retroflex (your NEW convention)
      { id:"g_tta",  glyph:"ट", hint:"ṭa",  level:2, stem:"tta" },
      { id:"g_ttha", glyph:"ठ", hint:"ṭha", level:2, stem:"ttha" },
      { id:"g_dda",  glyph:"ड", hint:"ḍa",  level:2, stem:"dda" },
      { id:"g_ddha", glyph:"ढ", hint:"ḍha", level:3, stem:"ddha" },
      { id:"g_nna",  glyph:"ण", hint:"ṇa",  level:2, stem:"nna" },

      // dentals
      { id:"g_ta",  glyph:"त", hint:"ta",  level:1, stem:"ta" },
      { id:"g_tha", glyph:"थ", hint:"tha", level:1, stem:"tha" },
      { id:"g_da",  glyph:"द", hint:"da",  level:1, stem:"da" },
      { id:"g_dha", glyph:"ध", hint:"dha", level:2, stem:"dha" },
      { id:"g_na",  glyph:"न", hint:"na",  level:1, stem:"na" },

      // labials
      { id:"g_pa",  glyph:"प", hint:"pa",  level:1, stem:"pa" },
      { id:"g_pha", glyph:"फ", hint:"pha", level:2, stem:"pha" },
      { id:"g_ba",  glyph:"ब", hint:"ba",  level:1, stem:"ba" },
      { id:"g_bha", glyph:"भ", hint:"bha", level:2, stem:"bha" },
      { id:"g_ma",  glyph:"म", hint:"ma",  level:1, stem:"ma" },

      // avargiya (optional as gunita)
      { id:"g_ya", glyph:"य", hint:"ya", level:1, stem:"ya" },
      { id:"g_ra", glyph:"र", hint:"ra", level:1, stem:"ra" },
      { id:"g_la", glyph:"ल", hint:"la", level:1, stem:"la" },
      { id:"g_va", glyph:"व", hint:"va", level:1, stem:"va" },
      { id:"g_sha",glyph:"श", hint:"śa", level:2, stem:"sha" },
      { id:"g_ssa",glyph:"ष", hint:"ṣa", level:2, stem:"ssa" }, // only if you used ssa_* naming
      { id:"g_sa", glyph:"स", hint:"sa", level:1, stem:"sa" },
      { id:"g_ha", glyph:"ह", hint:"ha", level:1, stem:"ha" }
    ];

    // OPTIONAL: a tiny inline QA list (Dataset = custom_inline)
    const QA_INLINE = [
      // { id:"x001", glyph:"अ", hint:"a", level:1, file:"a.mp3", module:"" },
    ];

    // -----------------------------
    // UI refs
    // -----------------------------
    const qaStatus = document.getElementById("qaStatus");
    const qaCounts = document.getElementById("qaCounts");
    const qaProgress = document.getElementById("qaProgress");

    const qaDataset = document.getElementById("qaDataset");
    const qaFilter = document.getElementById("qaFilter");
    const qaLevel = document.getElementById("qaLevel");
    const qaModuleWrap = document.getElementById("qaModuleWrap");
    const qaModule = document.getElementById("qaModule");
    const dsHelp = document.getElementById("dsHelp");

    const qaPrev = document.getElementById("qaPrev");
    const qaNext = document.getElementById("qaNext");
    const qaPlay = document.getElementById("qaPlay");
    const qaApprove = document.getElementById("qaApprove");
    const qaReject = document.getElementById("qaReject");
    const qaClearDecision = document.getElementById("qaClearDecision");
    const qaResetAll = document.getElementById("qaResetAll");

    const qaGlyph = document.getElementById("qaGlyph");
    const qaHint = document.getElementById("qaHint");
    const qaId = document.getElementById("qaId");
    const qaModuleTag = document.getElementById("qaModuleTag");
    const qaLevelTag = document.getElementById("qaLevelTag");
    const qaDecision = document.getElementById("qaDecision");
    const qaAudioFile = document.getElementById("qaAudioFile");
    const qaMissingNote = document.getElementById("qaMissingNote");

    const qaNote = document.getElementById("qaNote");
    const qaSaveNote = document.getElementById("qaSaveNote");
    const qaExport = document.getElementById("qaExport");
    const jumpInline = document.getElementById("jumpInline");

    // -----------------------------
    // Audio player
    // -----------------------------
    const player = new Audio();
    player.preload = "auto";

    function setStatus(msg, kind="neutral"){
      qaStatus.textContent = msg;
      qaStatus.classList.remove("okPill","badPill","warnPill");
      if (kind==="ok") qaStatus.classList.add("okPill");
      if (kind==="bad") qaStatus.classList.add("badPill");
      if (kind==="warn") qaStatus.classList.add("warnPill");
    }

    function playFile(file, label="audio"){
      if (!file) { setStatus("No audio for this item", "warn"); return; }
      try { player.pause(); player.currentTime = 0; } catch(e){}
      const url = AUDIO_BASE_URL + file.replace(/^\/+/,"");
      player.src = url;
      setStatus("Loading…", "neutral");
      player.play()
        .then(()=> setStatus("Playing", "ok"))
        .catch(()=> setStatus("Could not play: " + url, "bad"));
    }

    // -----------------------------
    // Load JSON datasets (words + conjuncts)
    // -----------------------------
    let WORDS = [], WORDS_READY = false;
    let CONJ_WORDS = [], CONJ_WORDS_READY = false;
    let CONJ = [], CONJ_READY = false;

    async function fetchJson(path){
      const res = await fetch(path + "?v=" + Date.now());
      if (!res.ok) throw new Error("HTTP " + res.status + " for " + path);
      return await res.json();
    }

    async function loadAll(){
      try{ WORDS = await fetchJson("words.json"); WORDS_READY = Array.isArray(WORDS); }
      catch(e){ console.error(e); WORDS=[]; WORDS_READY=false; }

      try{ CONJ_WORDS = await fetchJson("conj/conjunct_words.json"); CONJ_WORDS_READY = Array.isArray(CONJ_WORDS); }
      catch(e){ console.error(e); CONJ_WORDS=[]; CONJ_WORDS_READY=false; }

      try{ CONJ = await fetchJson("conj/conjuncts.json"); CONJ_READY = Array.isArray(CONJ); }
      catch(e){ console.error(e); CONJ=[]; CONJ_READY=false; }

      setStatus("Loaded datasets", "ok");
      qaRebuildList(true);
    }

    // -----------------------------
    // QA storage
    // -----------------------------
    let qaAll = [];
    let qaList = [];
    let qaIdx = -1;

    const LS_KEY = "uccharanam_qa_v2";

    function loadStore(){
      try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
      catch(e){ return {}; }
    }
    function saveStore(obj){ localStorage.setItem(LS_KEY, JSON.stringify(obj)); }
    function getEntry(key){ const st = loadStore(); return st[key] || null; }
    function setEntry(key, patch){
      const st = loadStore();
      st[key] = { ...(st[key]||{}), ...patch, t: Date.now() };
      saveStore(st);
    }
    function clearEntry(key){
      const st = loadStore();
      delete st[key];
      saveStore(st);
    }
    function resetStore(){ localStorage.removeItem(LS_KEY); }

    function conjIdToModuleMap(){
      const m = new Map();
      if (Array.isArray(CONJ)) CONJ.forEach(x => { if (x && x.id) m.set(x.id, x.module || ""); });
      return m;
    }

    // -----------------------------
    // Build items per dataset
    // item model: { key, id, glyph, hint, level, file, module, source }
    // -----------------------------
    function buildGunitaItems(){
      const out = [];
      for (const c of GUNITA_STEMS){
        for (const v of GUNITA_VOWELS){
          const file = `${c.stem}_${v.key}.mp3`;
          // We cannot reliably generate the Devanagari combined form without a full matra engine,
          // so for QA we display: consonant + (vowel key) which is enough for reviewers.
          const glyph = `${c.glyph} + ${v.label}`;
          const hint = `${c.hint}${v.hint ? " + " + v.hint : ""}`;
          const id = `${c.id}_${v.key}`;
          out.push({
            key: `gunita:${id}:${file}`,
            id,
            glyph,
            hint,
            level: c.level,
            file,
            module: "",
            source: "gunita_generated"
          });
        }
      }
      return out;
    }

    function buildDatasetItems(){
      const ds = qaDataset.value;
      const items = [];

      if (ds === "vowels"){
        QA_VOWELS.forEach(x=>{
          items.push({
            key: `vowels:${x.id}:${x.file}`,
            id: x.id, glyph: x.glyph, hint: x.hint, level: x.level ?? "",
            file: x.file, module:"", source:"built_in_vowels"
          });
        });
      }

      if (ds === "vargiya"){
        QA_VARGIYA.forEach(x=>{
          items.push({
            key: `vargiya:${x.id}:${x.file}`,
            id: x.id, glyph: x.glyph, hint: x.hint, level: x.level ?? "",
            file: x.file, module:"", source:"built_in_vargiya"
          });
        });
      }

      if (ds === "avargiya"){
        QA_AVARGIYA.forEach(x=>{
          items.push({
            key: `avargiya:${x.id}:${x.file}`,
            id: x.id, glyph: x.glyph, hint: x.hint, level: x.level ?? "",
            file: x.file, module:"", source:"built_in_avargiya"
          });
        });
      }

      if (ds === "gunita"){
        buildGunitaItems().forEach(it=>items.push(it));
      }

      if (ds === "gunita_words") {
        if (WORDS_READY) {
          WORDS.forEach(w=>{
            const id = w.id || "";
            const glyph = w.word || "";
            const hint = w.hint || "";
            const level = w.level ?? "";
            const file = w.file || "";
            const key = `words:${id}:${file}`;
            items.push({ key, id, glyph, hint, level, file, module:"", source:"words.json" });
          });
        }
      }

      if (ds === "conj_words") {
        if (CONJ_WORDS_READY) {
          const idToMod = conjIdToModuleMap();
          CONJ_WORDS.forEach(w=>{
            const cid = w.conj_id || "";
            const glyph = w.word || "";
            const hint = w.hint || "";
            const level = w.level ?? "";
            const file = w.file || "";
            const mod = idToMod.get(cid) || "";
            const idx = w.idx ?? "";
            const key = `conj_words:${cid}:${idx}:${file}`;
            items.push({ key, id: cid, glyph, hint, level, file, module: mod, source:"conj/conjunct_words.json" });
          });
        }
      }

      if (ds === "conj_items") {
        if (CONJ_READY) {
          CONJ.forEach(x=>{
            const id = x.id || "";
            const glyph = x.form || "";
            const hint = x.hint || "";
            const mod = x.module || "";
            const file = x.audio || "";
            const level = "";
            const key = `conj_items:${id}:${file}`;
            items.push({ key, id, glyph, hint, level, file, module: mod, source:"conj/conjuncts.json" });
          });
        }
      }

      if (ds === "custom_inline") {
        QA_INLINE.forEach(x=>{
          const id = x.id || "";
          const glyph = x.glyph || "";
          const hint = x.hint || "";
          const level = x.level ?? "";
          const file = x.file || "";
          const mod = x.module || "";
          const key = `inline:${id}:${file}`;
          items.push({ key, id, glyph, hint, level, file, module: mod, source:"qa_inline" });
        });
      }

      return items.filter(x => x && x.glyph);
    }

    function applyFilters(items){
      const f = qaFilter.value;
      const lvl = qaLevel.value;
      const mod = qaModule.value;

      return items.filter(it=>{
        const entry = getEntry(it.key);
        const decision = entry?.decision || "";

        if (f === "unreviewed" && decision) return false;
        if (f === "approved" && decision !== "approved") return false;
        if (f === "rejected" && decision !== "rejected") return false;

        if (lvl !== "all" && String(it.level ?? "") !== String(lvl)) return false;

        if (qaModuleWrap.style.display !== "none") {
          if (mod !== "ALL" && String(it.module || "") !== String(mod)) return false;
        }

        return true;
      });
    }

    function updateCounts(){
      const all = qaAll.length;
      let approved=0, rejected=0, unreviewed=0;
      qaAll.forEach(it=>{
        const d = (getEntry(it.key)?.decision || "");
        if (d==="approved") approved++;
        else if (d==="rejected") rejected++;
        else unreviewed++;
      });
      qaCounts.textContent = `All: ${all} · ✅ ${approved} · ❌ ${rejected} · ⏳ ${unreviewed}`;
      qaProgress.textContent = (!qaList.length) ? "0 / 0" : `${qaIdx+1} / ${qaList.length}`;
    }

    function currentItem(){ return (qaIdx>=0 && qaIdx<qaList.length) ? qaList[qaIdx] : null; }

    function renderCurrent(){
      const it = currentItem();
      updateCounts();

      if (!it){
        qaGlyph.textContent = "—";
        qaHint.textContent = "hint: —";
        qaId.textContent = "id: —";
        qaModuleTag.style.display = "none";
        qaLevelTag.textContent = "level: —";
        qaDecision.textContent = "Decision: —";
        qaAudioFile.textContent = "Audio: —";
        qaMissingNote.style.display = "none";
        qaNote.value = "";
        setStatus("No items for this filter", "warn");
        return;
      }

      qaGlyph.textContent = it.glyph;
      qaHint.textContent = "hint: " + (it.hint || "—");
      qaId.textContent = "id: " + (it.id || "—");
      qaLevelTag.textContent = "level: " + (it.level === "" ? "—" : it.level);

      if (it.module) {
        qaModuleTag.style.display = "inline-block";
        qaModuleTag.textContent = "module: " + it.module;
      } else {
        qaModuleTag.style.display = "none";
      }

      qaAudioFile.textContent = "Audio: " + (it.file || "(blank)");
      qaMissingNote.style.display = (!it.file) ? "block" : "none";

      const entry = getEntry(it.key);
      const decision = entry?.decision || "";
      qaNote.value = entry?.note || "";

      if (!decision) qaDecision.textContent = "Decision: —";
      if (decision==="approved") qaDecision.textContent = "Decision: ✅ Approved";
      if (decision==="rejected") qaDecision.textContent = "Decision: ❌ Rejected";
    }

    function qaRebuildList(resetIndex=false){
      const ds = qaDataset.value;

      // show Module filter only for conjunct datasets
      const needsModule = (ds === "conj_words" || ds === "conj_items");
      qaModuleWrap.style.display = needsModule ? "inline-flex" : "none";

      // dataset-specific help
      dsHelp.style.display = (ds === "gunita") ? "block" : "none";

      qaAll = buildDatasetItems();
      qaList = applyFilters(qaAll);

      if (resetIndex) qaIdx = -1;
      if (qaIdx >= qaList.length) qaIdx = qaList.length - 1;
      renderCurrent();
    }

    // -----------------------------
    // Actions
    // -----------------------------
    function qaNextAndPlay(){
      if (!qaList.length) { renderCurrent(); return; }
      qaIdx++;
      if (qaIdx >= qaList.length) qaIdx = 0;
      renderCurrent();
      qaPlayNow();
    }

    function qaPrevOnly(){
      if (!qaList.length) { renderCurrent(); return; }
      qaIdx--;
      if (qaIdx < 0) qaIdx = qaList.length - 1;
      renderCurrent();
    }

    function qaPlayNow(){
      const it = currentItem();
      if (!it) return;
      playFile(it.file, it.glyph);
    }

    function qaApproveNow(){
      const it = currentItem();
      if (!it) return;
      setEntry(it.key, { decision: "approved" });
      setStatus("Approved", "ok");
      renderCurrent();
    }

    function qaRejectNow(){
      const it = currentItem();
      if (!it) return;
      setEntry(it.key, { decision: "rejected" });
      setStatus("Rejected", "bad");
      renderCurrent();
    }

    function qaClearDecisionNow(){
      const it = currentItem();
      if (!it) return;
      const entry = getEntry(it.key);
      if (entry?.note) setEntry(it.key, { decision: "" });
      else clearEntry(it.key);
      setStatus("Cleared decision", "neutral");
      renderCurrent();
    }

    function qaSaveNoteNow(){
      const it = currentItem();
      if (!it) return;
      const note = (qaNote.value || "").trim();
      setEntry(it.key, { note });
      setStatus(note ? "Note saved" : "Note cleared", "ok");
      renderCurrent();
    }

    function qaResetEverything(){
      if (!confirm("This will delete ALL QA decisions/notes saved in this browser for this tool. Continue?")) return;
      resetStore();
      setStatus("QA data reset", "warn");
      qaRebuildList(false);
    }

    function tsvEscape(s){
      s = (s ?? "").toString();
      return s.replace(/\t/g," ").replace(/\r?\n/g,"  ");
    }

    function qaExportTSV(){
      const st = loadStore();
      const rows = [];
      rows.push(["key","dataset","id","glyph","hint","level","module","file","decision","note","timestamp"].join("\t"));

      qaAll.forEach(it=>{
        const entry = st[it.key] || {};
        const decision = entry.decision || "";
        const note = entry.note || "";
        const ts = entry.t ? new Date(entry.t).toISOString() : "";
        rows.push([
          tsvEscape(it.key),
          tsvEscape(it.source),
          tsvEscape(it.id),
          tsvEscape(it.glyph),
          tsvEscape(it.hint),
          tsvEscape(it.level),
          tsvEscape(it.module),
          tsvEscape(it.file),
          tsvEscape(decision),
          tsvEscape(note),
          tsvEscape(ts),
        ].join("\t"));
      });

      const blob = new Blob([rows.join("\n")], { type: "text/tab-separated-values;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "qa_export.tsv";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus("Exported qa_export.tsv", "ok");
    }

    // -----------------------------
    // Wiring
    // -----------------------------
    qaDataset.addEventListener("change", ()=> qaRebuildList(true));
    qaFilter.addEventListener("change", ()=> qaRebuildList(true));
    qaLevel.addEventListener("change", ()=> qaRebuildList(true));
    qaModule.addEventListener("change", ()=> qaRebuildList(true));

    qaPrev.addEventListener("click", qaPrevOnly);
    qaNext.addEventListener("click", qaNextAndPlay);
    qaPlay.addEventListener("click", qaPlayNow);
    qaApprove.addEventListener("click", qaApproveNow);
    qaReject.addEventListener("click", qaRejectNow);
    qaClearDecision.addEventListener("click", qaClearDecisionNow);
    qaSaveNote.addEventListener("click", qaSaveNoteNow);
    qaExport.addEventListener("click", qaExportTSV);
    qaResetAll.addEventListener("click", qaResetEverything);

    jumpInline.addEventListener("click", ()=>{
      qaDataset.value = "custom_inline";
      qaRebuildList(true);
      setStatus("Now using Custom inline list (edit QA_INLINE in qa.html)", "warn");
    });

    document.addEventListener("keydown", (e)=>{
      const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
      if (tag === "textarea" || tag === "input" || tag === "select") return;

      const k = e.key.toLowerCase();
      if (k === "n") { e.preventDefault(); qaNextAndPlay(); }
      if (k === "p" || k === " ") { e.preventDefault(); qaPlayNow(); }
      if (k === "a") { e.preventDefault(); qaApproveNow(); }
      if (k === "r") { e.preventDefault(); qaRejectNow(); }
    });

    // -----------------------------
    // Boot
    // -----------------------------
    loadAll().then(()=>{
      setStatus("Ready — press Next (Play)", "ok");
    });
  </script>
</body>
</html>
